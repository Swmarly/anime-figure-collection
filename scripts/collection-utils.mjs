import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DATA_PATH = path.resolve(__dirname, "../data/collection.json");
const FIGURES_MODULE_PATH = path.resolve(__dirname, "../figures.js");

const RELEASE_FALLBACK = -Infinity;

const releaseKey = (value) => {
  if (!value) return RELEASE_FALLBACK;
  if (typeof value !== "string") return RELEASE_FALLBACK;
  const [year, month = "00"] = value.split("-");
  if (!year) return RELEASE_FALLBACK;
  const normalizedMonth = month.padStart(2, "0");
  const numeric = Number(`${year}${normalizedMonth}`);
  return Number.isFinite(numeric) ? numeric : RELEASE_FALLBACK;
};

const baseSlugify = (value) =>
  value
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");

export const slugify = (entry) => {
  if (!entry) return null;
  if (entry.slug) return entry.slug;
  if (entry.name) {
    const slug = baseSlugify(entry.name);
    if (slug) return slug;
  }
  if (entry.mfcId) return `mfc-${entry.mfcId}`;
  return null;
};

export const loadCollection = async () => {
  const content = await readFile(DATA_PATH, "utf8");
  const parsed = JSON.parse(content);
  return {
    owned: Array.isArray(parsed.owned) ? parsed.owned : [],
    wishlist: Array.isArray(parsed.wishlist) ? parsed.wishlist : [],
  };
};

export const sortEntries = (entries) => {
  return [...entries].sort((a, b) => {
    const releaseA = releaseKey(a.releaseDate);
    const releaseB = releaseKey(b.releaseDate);

    if (releaseA !== releaseB) {
      return releaseB - releaseA;
    }

    const nameA = (a.name ?? "").toLowerCase();
    const nameB = (b.name ?? "").toLowerCase();
    if (nameA && nameB) return nameA.localeCompare(nameB);
    if (nameA) return -1;
    if (nameB) return 1;
    return 0;
  });
};

export const normalizeEntry = (entry) => {
  const normalized = { ...entry };
  normalized.slug = slugify(entry);
  if (!normalized.slug) {
    throw new Error(
      "Unable to derive slug. Please provide a name or set the `slug` field explicitly."
    );
  }

  if (typeof normalized.tags === "string") {
    normalized.tags = normalized.tags
      .split(",")
      .map((tag) => tag.trim())
      .filter(Boolean);
  }

  if (!Array.isArray(normalized.tags)) {
    normalized.tags = [];
  }

  if (typeof normalized.releaseDate === "string") {
    normalized.releaseDate = normalized.releaseDate.trim() || null;
  }

  if (normalized.releaseDate === "") {
    normalized.releaseDate = null;
  }

  return normalized;
};

export const saveCollection = async (collection) => {
  const payload = {
    owned: sortEntries(collection.owned ?? []).map(normalizeEntry),
    wishlist: sortEntries(collection.wishlist ?? []).map(normalizeEntry),
  };

  const json = `${JSON.stringify(payload, null, 2)}\n`;
  await writeFile(DATA_PATH, json, "utf8");
  return payload;
};

const buildLinks = (entry) => {
  const links = { ...(entry.links ?? {}) };
  if (entry.mfcId && !links.mfc) {
    links.mfc = `https://myfigurecollection.net/item/${entry.mfcId}`;
  }
  return Object.keys(links).length ? links : undefined;
};

export const entryToFigure = (entry) => {
  const normalized = normalizeEntry(entry);
  const figure = {
    id: normalized.slug,
    name: normalized.name ?? (normalized.mfcId ? `MFC Item ${normalized.mfcId}` : "Untitled figure"),
    series: normalized.series ?? "",
    manufacturer: normalized.manufacturer ?? "",
    scale: normalized.scale ?? "",
    releaseDate: normalized.releaseDate ?? null,
    image: normalized.image ?? "",
  };

  if (normalized.caption) figure.caption = normalized.caption;
  if (normalized.description) figure.description = normalized.description;
  if (normalized.alt) figure.alt = normalized.alt;
  if (Array.isArray(normalized.tags) && normalized.tags.length) {
    figure.tags = normalized.tags;
  }
  if (normalized.mfcId) figure.mfcId = normalized.mfcId;

  const links = buildLinks(normalized);
  if (links) {
    figure.links = links;
  }

  return figure;
};

export const writeFiguresModule = async (collection) => {
  const normalized = {
    owned: sortEntries(collection.owned ?? []).map(normalizeEntry),
    wishlist: sortEntries(collection.wishlist ?? []).map(normalizeEntry),
  };

  const figures = normalized.owned.map(entryToFigure);
  const wishlist = normalized.wishlist.map(entryToFigure);

  const header = "// Auto-generated by scripts/generate-figures.mjs â€” do not edit manually\n";
  const body = `export const figures = ${JSON.stringify(figures, null, 2)};\n\nexport const wishlist = ${JSON.stringify(wishlist, null, 2)};\n`;
  await writeFile(FIGURES_MODULE_PATH, `${header}${body}`, "utf8");
};

export const updateFiguresModule = async () => {
  const collection = await loadCollection();
  await writeFiguresModule(collection);
};
